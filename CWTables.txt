drop schema TicketSystem cascade;
create schema TicketSystem;
set search_path to TicketSystem;

CREATE TABLE Staff
(
	StaffID		INTEGER PRIMARY KEY
	    check (StaffID > 0),
	Name			VARCHAR(40) NOT NULL
		check (Name <> '')
);

CREATE TABLE Product
(
	ProductID		INTEGER PRIMARY KEY
	    check (ProductID > 0),
	Name			VARCHAR(40) NOT NULL
		check (Name <> '')
);

CREATE TABLE Customer
(
	CustomerID		INTEGER PRIMARY KEY
	    check (CustomerID > 0),
	Name			VARCHAR(40) NOT NULL
		check (Name <> ''),
	Email			VARCHAR(40) NOT NULL UNIQUE
		check (Email <> '')
);

CREATE TABLE Ticket
(
	TicketID		INTEGER PRIMARY KEY
	    check (TicketID > 0),
	Problem		VARCHAR(1000) NOT NULL
		check (Problem <> ''),
	Status		VARCHAR(20) NOT NULL,
	Priority		INTEGER NOT NULL
		CHECK (Priority >= 1 and Priority <= 3),
	LoggedTime		TIMESTAMP NOT NULL,
	CustomerID		INTEGER NOT NULL,
	FOREIGN KEY (CustomerID) REFERENCES Customer
			ON DELETE RESTRICT
			ON UPDATE CASCADE,
	ProductID		INTEGER NOT NULL,
	FOREIGN KEY (ProductID) REFERENCES Product
			ON DELETE CASCADE
			ON UPDATE CASCADE
);

CREATE TABLE TicketUpdate
(
	TicketUpdateID	INTEGER PRIMARY KEY
	    check (TicketUpdateID > 0),
	Message		VARCHAR(1000) NOT NULL
		check (Message <> ''),
	UpdateTime		TIMESTAMP NOT NULL,
	TicketID		INTEGER NOT NULL,
	FOREIGN KEY (TicketID) REFERENCES Ticket
			ON DELETE CASCADE
			ON UPDATE CASCADE,
	StaffID		INTEGER,
	FOREIGN KEY (StaffID) REFERENCES Staff
			ON DELETE RESTRICT
			ON UPDATE CASCADE
);

create or replace function ticketHasUpdate (integer) returns bool as $$
	SELECT EXISTS(select TicketID from TicketUpdate where TicketID = $1);
$$
	language sql;
	
Alter table Ticket
	add constraint status_check check ((Status = 'open') or (Status = 'closed' and ticketHasUpdate(TicketID) = true));

create or replace function StatusDomainIntegrityCorrection() returns trigger as $$
begin
update ticket set status = 'open' where (tickethasupdate(ticketID) = false);
return new;
end
$$ language plpgsql;

create trigger StatusDomainIntegrityTrigger
after delete on ticketupdate
execute procedure StatusDomainIntegrityCorrection();	

create view openticketlatestupdate as
	select ticket.ticketid, to_char(max(updatetime), 'YYYY MM DD HH24:MI:SS') as LatestUpdate from ticket join ticketupdate
	on ticket.ticketid = ticketupdate.ticketid and status = 'open' group by ticket.ticketid;

create or replace function 	ticketandupdates(ticktid int) returns table(atime text, mess character varying, thor character varying) as $$
declare
	customer character varying := name from ticket, customer
	where ticket.customerid = customer.customerid and ticketid = $1;
begin
return query select * from (select to_char(loggedtime, 'YYYY MM DD HH24:MI:SS') as loggedtime, message, author from
(select * from (
    select loggedtime, problem as message, name as author from ticket, customer where ticketid = $1
    union
    select updatetime as loggedtime, message, name as author
        from ticketupdate, staff where ticketid = $1
    union
    select updatetime as loggedtime, message, customer as author
        from ticketupdate, staff where (ticketupdate.staffid is null) and ticketid = $1)
as temp order by loggedtime) as temp) as temp;
end
$$ language plpgsql;

create type closedticketstatus as
	(number_of_updates int, problem_description character varying, timeuntilfirstupdate text, timeuntillastupdate text);

create or replace function ticketupdatestatus() returns setof closedticketstatus as $$
declare
	ids bigint[] := array(select ticketid from ticket where status = 'closed');
	id bigint;

	description character varying;
	num_updates int;
	original_time timestamp;
	first_update_time timestamp;
	latest_update_time timestamp;

	ret record;
begin
	foreach id in array ids
	loop
		num_updates := count(*) from ticketupdate where ticketid = id;
		description := problem from ticket where ticketid = id;
		original_time := loggedtime from ticket where ticketid = id;
		first_update_time := min(updatetime) from ticketupdate where ticketid = id;
		latest_update_time := max(updatetime) from ticketupdate where ticketid = id;

		select num_updates, description,
		to_char(first_update_time-original_time, 'DD HH24:MI:SS'),
		to_char(latest_update_time-original_time, 'DD HH24:MI:SS')
		into ret;

		return next ret;
	end	loop;
end
$$ language plpgsql;

create or replace view closedticketupdatestatus
	as select * from ticketupdatestatus();


--EXPECT INDEX INSTRUCTIONS HERE
CREATE INDEX Status_index on Ticket (Status);
CREATE INDEX Ticket_index on TicketUpdate (Ticket);
